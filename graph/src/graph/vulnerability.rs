//! Support for CVEs.

use crate::graph::advisory::AdvisoryContext;
use crate::graph::error::Error;
use crate::graph::Graph;
use sea_orm::ActiveValue::{Set, Unchanged};
use sea_orm::{
    ActiveModelTrait, ColumnTrait, EntityTrait, ModelTrait, NotSet, QueryFilter, QuerySelect,
    RelationTrait,
};
use sea_query::JoinType;
use std::fmt::{Debug, Formatter};
use trustify_common::db::Transactional;
use trustify_entity as entity;
use trustify_entity::vulnerability::Model;
use trustify_entity::{advisory, advisory_vulnerability, vulnerability, vulnerability_description};

impl Graph {
    pub async fn ingest_vulnerability<TX: AsRef<Transactional>>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<VulnerabilityContext, Error> {
        if let Some(found) = self.get_vulnerability(identifier, &tx).await? {
            Ok(found)
        } else {
            let entity = vulnerability::ActiveModel {
                id: Default::default(),
                identifier: Set(identifier.to_string()),
                title: NotSet,
            };

            Ok((self, entity.insert(&self.connection(&tx)).await?).into())
        }
    }

    pub async fn get_vulnerability<TX: AsRef<Transactional>>(
        &self,
        identifier: &str,
        tx: TX,
    ) -> Result<Option<VulnerabilityContext>, Error> {
        Ok(vulnerability::Entity::find()
            .filter(vulnerability::Column::Identifier.eq(identifier))
            .one(&self.connection(&tx))
            .await?
            .map(|cve| (self, cve).into()))
    }
}

#[derive(Clone)]
pub struct VulnerabilityContext {
    pub(crate) graph: Graph,
    pub(crate) vulnerability: vulnerability::Model,
}

impl Debug for VulnerabilityContext {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        self.vulnerability.fmt(f)
    }
}

impl From<(&Graph, vulnerability::Model)> for VulnerabilityContext {
    fn from((system, cve): (&Graph, Model)) -> Self {
        Self {
            graph: system.clone(),
            vulnerability: cve,
        }
    }
}

impl VulnerabilityContext {
    pub async fn advisories<TX: AsRef<Transactional>>(
        &self,
        tx: TX,
    ) -> Result<Vec<AdvisoryContext>, Error> {
        Ok(advisory::Entity::find()
            .join(
                JoinType::Join,
                advisory_vulnerability::Relation::Advisory.def().rev(),
            )
            .filter(advisory_vulnerability::Column::VulnerabilityId.eq(self.vulnerability.id))
            .all(&self.graph.connection(&tx))
            .await?
            .drain(0..)
            .map(|advisory| (&self.graph, advisory).into())
            .collect())
    }

    pub async fn set_title<TX: AsRef<Transactional>>(
        &self,
        title: Option<String>,
        tx: TX,
    ) -> Result<(), Error> {
        let mut entity: vulnerability::ActiveModel = self.vulnerability.clone().into();
        entity.title = Set(title);

        entity.save(&self.graph.connection(&tx)).await?;

        Ok(())
    }

    pub async fn add_description<TX: AsRef<Transactional>>(
        &self,
        lang: &str,
        description: &str,
        tx: TX,
    ) -> Result<(), Error> {
        let model = vulnerability_description::ActiveModel {
            id: Default::default(),
            vulnerability_id: Set(self.vulnerability.id),
            lang: Set(lang.to_string()),
            description: Set(description.to_string()),
        };

        model.save(&self.graph.connection(&tx)).await?;

        Ok(())
    }

    pub async fn descriptions<TX: AsRef<Transactional>>(
        &self,
        lang: &str,
        tx: TX,
    ) -> Result<Vec<String>, Error> {
        Ok(self
            .vulnerability
            .find_related(entity::vulnerability_description::Entity)
            .filter(vulnerability_description::Column::Lang.eq(lang))
            .all(&self.graph.connection(&tx))
            .await?
            .drain(..)
            .map(|e| e.description)
            .collect())
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use crate::graph::Graph;
    use test_log::test;
    use trustify_common::db::{Database, Transactional};

    #[test(tokio::test)]
    async fn ingest_cves() -> Result<(), anyhow::Error> {
        let db = Database::for_test("ingest_cve").await?;
        let system = Graph::new(db);

        let cve1 = system
            .ingest_vulnerability("CVE-123", Transactional::None)
            .await?;
        let cve2 = system
            .ingest_vulnerability("CVE-123", Transactional::None)
            .await?;
        let cve3 = system
            .ingest_vulnerability("CVE-456", Transactional::None)
            .await?;

        assert_eq!(cve1.vulnerability.id, cve2.vulnerability.id);
        assert_ne!(cve1.vulnerability.id, cve3.vulnerability.id);

        let not_found = system
            .get_vulnerability("CVE-NOT_FOUND", Transactional::None)
            .await?;

        assert!(not_found.is_none());

        Ok(())
    }

    #[test(tokio::test)]
    async fn get_advisories_from_cve() -> Result<(), anyhow::Error> {
        let db = Database::for_test("get_advisories_from_cve").await?;
        let system = Graph::new(db);

        let advisory1 = system
            .ingest_advisory("GHSA-1", "http://ghsa.io/GHSA-1", "7", Transactional::None)
            .await?;

        let advisory2 = system
            .ingest_advisory("RHSA-1", "http://rhsa.io/RHSA-1", "8", Transactional::None)
            .await?;

        let advisory3 = system
            .ingest_advisory("SNYK-1", "http://snyk.io/SNYK-1", "9", Transactional::None)
            .await?;

        advisory1
            .ingest_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        advisory2
            .ingest_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        let cve = system
            .get_vulnerability("CVE-8675309", Transactional::None)
            .await?;

        assert!(cve.is_some());

        let cve = cve.unwrap();

        let linked_advisories = cve.advisories(Transactional::None).await?;

        assert_eq!(2, linked_advisories.len());

        assert!(linked_advisories.contains(&advisory1));
        assert!(linked_advisories.contains(&advisory2));

        Ok(())
    }
}
