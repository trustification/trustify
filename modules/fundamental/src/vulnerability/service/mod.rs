#[cfg(test)]
mod test;

use crate::vulnerability::model::AnalysisResult;
use crate::{
    Error,
    advisory::model::AdvisoryHead,
    vulnerability::model::{
        AnalysisAdvisory, AnalysisDetails, AnalysisResponse, Score, ScoreType,
        VulnerabilityDetails, VulnerabilityHead, VulnerabilitySummary,
    },
};
use futures_util::{TryFutureExt, TryStreamExt, future};
use sea_orm::{
    EntityTrait, FromQueryResult, Statement, StreamTrait, TryGetableFromJson, prelude::*,
};
use std::collections::btree_map::Entry;
use std::{
    collections::{BTreeMap, HashMap},
    str::FromStr,
};
use tracing::instrument;
use trustify_common::{
    db::{
        limiter::LimiterTrait,
        query::{Columns, Filtering, Query},
    },
    memo::Memo,
    model::{Paginated, PaginatedResults},
    purl::Purl,
};
use trustify_entity::{advisory, cvss3, vulnerability};
use trustify_module_ingestor::common::Deprecation;

#[derive(Default)]
pub struct VulnerabilityService {}

impl VulnerabilityService {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn fetch_vulnerabilities<C: ConnectionTrait + Sync + Send>(
        &self,
        search: Query,
        paginated: Paginated,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<PaginatedResults<VulnerabilitySummary>, Error> {
        let limiter = vulnerability::Entity::find()
            .filtering_with(search, Columns::from_entity::<vulnerability::Entity>())?
            .limiting(connection, paginated.offset, paginated.limit);

        let total = limiter.total().await?;
        let vulnerabilities = limiter.fetch().await?;

        Ok(PaginatedResults {
            total,
            items: VulnerabilitySummary::from_entities(&vulnerabilities, deprecation, connection)
                .await?,
        })
    }

    pub async fn fetch_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        identifier: &str,
        deprecation: Deprecation,
        connection: &C,
    ) -> Result<Option<VulnerabilityDetails>, Error> {
        if let Some(vulnerability) = vulnerability::Entity::find_by_id(identifier)
            .one(connection)
            .await?
        {
            Ok(Some(
                VulnerabilityDetails::from_entity(&vulnerability, deprecation, connection).await?,
            ))
        } else {
            Ok(None)
        }
    }

    #[instrument(
        skip(self, connection),
        err(level=tracing::Level::INFO),
    )]
    pub async fn delete_vulnerability<C: ConnectionTrait + Sync + Send>(
        &self,
        id: &str,
        connection: &C,
    ) -> Result<u64, Error> {
        let query = vulnerability::Entity::delete_by_id(id);

        let result = query.exec(connection).await?;

        Ok(result.rows_affected)
    }

    #[instrument(
        skip_all,
        err(level=tracing::Level::INFO),
    )]
    pub async fn analyze_purls<C>(
        &self,
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &C,
    ) -> Result<AnalysisResponse, Error>
    where
        C: ConnectionTrait + StreamTrait,
    {
        let mut warnings = HashMap::new();
        let query = Self::build_query(purls, connection, &mut warnings)?;

        let stmt = Statement::from_string(connection.get_database_backend(), query);
        log::debug!("Analyzing using: {stmt}");
        let result = connection.stream(stmt).map_err(Error::from).await?;
        let mut result = result
            .map_err(Error::from)
            .and_then(|row| Self::row_to_vuln(row, connection))
            .try_fold(
                BTreeMap::new(),
                |mut acc: BTreeMap<String, AnalysisResult>, (requested_purl, head)| {
                    match acc.entry(requested_purl.clone()) {
                        Entry::Vacant(entry) => {
                            entry.insert(AnalysisResult {
                                details: vec![head],
                                warnings: warnings.remove(&requested_purl).unwrap_or_default(),
                            });
                        }
                        Entry::Occupied(mut entry) => {
                            entry.get_mut().details.push(head);
                        }
                    };

                    future::ok(acc)
                },
            )
            .await?;

        // add the remaining warnings

        for (purl, warnings) in warnings {
            result.entry(purl).or_default().warnings.extend(warnings);
        }

        Ok(AnalysisResponse(result))
    }

    /// Build the query for finding matching vulnerabilities
    fn build_query(
        purls: impl IntoIterator<Item = impl AsRef<str>>,
        connection: &impl ConnectionTrait,
        warnings: &mut HashMap<String, Vec<String>>,
    ) -> Result<String, Error> {
        let query = purls
            .into_iter()
            .map(|p| {
                let p = p.as_ref();
                let purl = Purl::from_str(p)?;

                let Some(version) = purl.version else {
                    warnings
                        .entry(p.to_string())
                        .or_default()
                        .push("Unable to process: missing version component".to_string());
                    return Ok(None);
                };

                let ns_condition = match &purl.namespace {
                    Some(namespace) => {
                        let sql = "base_purl.namespace = $1";
                        Statement::from_sql_and_values(
                            connection.get_database_backend(),
                            sql,
                            [namespace.into()],
                        )
                        .to_string()
                    }
                    None => "base_purl.namespace IS NULL".to_string(),
                };

                let sql = format!(
                    r#"
SELECT
  $1 as requested_purl,
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  jsonb_agg(
    jsonb_build_object(
      'status', status.slug,
      'id', purl_status.advisory_id
    )
  ) AS advisories
FROM base_purl
  LEFT JOIN purl_status ON base_purl.id = purl_status.base_purl_id
  INNER JOIN version_range ON purl_status.version_range_id = version_range.id
  LEFT JOIN vulnerability ON purl_status.vulnerability_id = vulnerability.id
  INNER JOIN status ON purl_status.status_id = status.id
WHERE {ns_condition}
  AND base_purl.name = $2
  AND base_purl.type = $3
  AND version_matches($4, version_range.*) = TRUE
  AND status.slug NOT IN (
    'fixed',
    'not_affected',
    'recommended'
  )
GROUP BY
  vulnerability.id,
  vulnerability.title,
  vulnerability.reserved,
  vulnerability.published,
  vulnerability.modified,
  vulnerability.withdrawn,
  vulnerability.cwes,
  requested_purl
"#
                );
                let query = Statement::from_sql_and_values(
                    connection.get_database_backend(),
                    &sql,
                    [p.into(), purl.name.into(), purl.ty.into(), version.into()],
                );

                Ok(Some(query.to_string()))
            })
            .filter_map(Result::transpose)
            .collect::<Result<Vec<String>, Error>>()?
            .join(" UNION ALL ");

        Ok(query)
    }

    /// Take a row from [`Self::build_query`] and turn it into a result entry
    ///
    /// This will return a tuple of the original PURL and then the result
    #[instrument(
        skip_all,
        fields(purl, id),
        err(level=tracing::Level::INFO),
    )]
    async fn row_to_vuln<C>(
        row: QueryResult,
        connection: &C,
    ) -> Result<(String, AnalysisDetails), Error>
    where
        C: ConnectionTrait + StreamTrait,
    {
        let requested_purl: String = row.try_get_by("requested_purl")?;

        let vulnerability = vulnerability::Model::from_query_result(&row, "")?;

        let span = tracing::Span::current();
        span.record("purl", &requested_purl);
        span.record("id", &vulnerability.id);

        let head = VulnerabilityHead::from_vulnerability_entity(
            &vulnerability,
            Memo::NotProvided,
            connection,
        )
        .await?;

        /// result struct for getting the array of status/advisory entries
        #[derive(serde::Deserialize)]
        struct Entry {
            status: String,
            id: Uuid,
        }

        impl TryGetableFromJson for Entry {}

        // deserialize from JSONB

        let advisories: Option<Vec<Entry>> = row.try_get_by("advisories")?;
        let ids = advisories
            .iter()
            .flatten()
            .map(|e| e.id)
            .collect::<Vec<_>>();

        // create a map for looking up the status once we resolved the ID to a struct

        let statuses = advisories
            .into_iter()
            .flatten()
            .map(|e| (e.id, e.status))
            .collect::<HashMap<_, _>>();

        // query for all the scores

        let scores = cvss3::Entity::find()
            .filter(cvss3::Column::AdvisoryId.is_in(ids.clone()))
            .filter(cvss3::Column::VulnerabilityId.eq(vulnerability.id))
            .stream(connection)
            .await?
            .map_err(Error::from)
            .try_filter_map(async |row| {
                // map to V3* type
                let r#type = match row.minor_version {
                    0 => ScoreType::V3,
                    1 => ScoreType::V3_1,
                    _ => return Ok(None),
                };

                Ok(Some((
                    row.advisory_id,
                    Score {
                        r#type,
                        value: row.score,
                        severity: row.score.into(),
                    },
                )))
            })
            .try_fold(
                HashMap::<Uuid, Vec<Score>>::new(),
                async move |mut acc, (advisory_id, entry)| {
                    acc.entry(advisory_id).or_default().push(entry);
                    Ok(acc)
                },
            )
            .await?;

        // query for all advisories and translate into map

        let status = advisory::Entity::find()
            .filter(advisory::Column::Id.is_in(ids))
            .stream(connection)
            .await?
            .map_err(Error::from)
            .try_filter_map(async |advisory| {
                let Some(status) = statuses.get(&advisory.id) else {
                    return Ok(None);
                };
                Ok(Some((
                    status.clone(),
                    AnalysisAdvisory {
                        advisory: AdvisoryHead::from_advisory(
                            &advisory,
                            Memo::NotProvided,
                            connection,
                        )
                        .await?,
                        // fetch scores from pre-loaded map
                        scores: scores
                            .get(&advisory.id)
                            .into_iter()
                            .flatten()
                            .copied()
                            .collect(),
                    },
                )))
            })
            .try_fold(
                BTreeMap::<String, Vec<AnalysisAdvisory>>::new(),
                async move |mut acc, (status, adv)| {
                    acc.entry(status.clone()).or_default().push(adv);
                    Ok(acc)
                },
            )
            .await?;

        Ok((requested_purl, AnalysisDetails { head, status }))
    }
}
